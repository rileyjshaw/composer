import math
import numpy
import scipy.io.wavfile as wav

sentinel = object()
sin = lambda f, t, sr: math.sin( 2 * math.pi * t * f / sr )

def generate_chord ( frequencies, duration, max_volume, sustain_volume = sentinel, sample_rate = 44100, adr = sentinel ):
    if sustain_volume == sentinel:
        sustain_volume = max_volume * 0.6
    if adr == sentinel:
        adr = [ duration * 0.05, duration * 0.05, duration * 0.3 ]

    duration *= sample_rate
    attack = sample_rate * adr[ 0 ]
    decay = sample_rate * adr[ 1 ]
    release = sample_rate * adr[ 2 ]
    sustain = duration - attack + decay + release

    if ( sustain < 0 ):
        raise AttributeError( "Total of attack, decay, and release values is greater than duration")

    try:
        len( frequencies )
    except TypeError as e:
        frequencies = [ frequencies ]

    tone = []
    d_start = attack
    s_start = d_start + decay
    r_start = s_start + sustain

    s_drop_factor = 1.0 - sustain_volume / max_volume

    a_envelope = lambda accum, f: accum + sin( f, t, sample_rate ) * max_volume * t / attack
    for t in numpy.arange( attack ):
        tone.append( reduce( a_envelope, frequencies ) )

    d_envelope = lambda accum, f: accum + sin( f, d_start + t, sample_rate ) * max_volume * ( 1 - s_drop_factor * t / decay )
    for t in numpy.arange( decay ):
        tone.append( reduce( d_envelope, frequencies ) )

    s_envelope = lambda accum, f: accum + sin( f, s_start + t, sample_rate ) * sustain_volume
    for t in numpy.arange( sustain ):
        tone.append( reduce( s_envelope, frequencies ) )

    r_envelope = lambda accum, f: accum + sin( f, r_start + t, sample_rate ) * sustain_volume * ( 1 - t / release )
    for t in numpy.arange( release ):
        tone.append( reduce( r_envelope, frequencies ) )

    return tone

def generate_song( chord_list ):
    return reduce( lambda accum, current: accum + generate_chord( *current ), chord_list, [] )

# Generated by my stupid ai
song = [ [ [ 440.0, 540.0, 320.0, 880.0 ], 1.0, 4000.0 ],
         [ [ 340.0, 620.0, 270.0, 130.0 ], 1.0, 4000.0 ],
         [ [ 670.0, 510.0, 210.0, 240.0 ], 1.0, 4000.0 ],
         [ [ 120.0, 580.0, 750.0, 350.0 ], 1.0, 4000.0 ],
         [ [ 540.0, 230.0, 130.0, 460.0 ], 1.0, 4000.0 ],
         [ [ 120.0, 140.0, 850.0, 570.0 ], 1.0, 4000.0 ],
         [ [ 760.0, 540.0, 170.0, 680.0 ], 1.0, 4000.0 ],
         [ [ 160.0, 840.0, 720.0, 680.0 ], 1.0, 4000.0 ] ]

wav.write( "sin_original.wav", 44100, numpy.array( generate_song( song ), dtype=numpy.int16 ) )
